---
title: Web Application Access
description: In this getting started guide, learn how to connect an application to your Teleport cluster by running the Teleport Application Service.
---

This guide shows you how to enroll a web application with your Teleport cluster
in order to set up role-based access controls, audit logging, and other Teleport
capabilities.

## How it works

To enroll a web application with your Teleport cluster, you deploy the Teleport
Application Service, which uses a join token to establish trust with the
Teleport Auth Service. Users visit Teleport-protected web applications through
the Teleport Web UI. The Teleport Proxy Service routes browser traffic to the
Teleport Application Service, which forwards HTTP requests to and from target
applications. 

## Prerequisites

(!docs/pages/includes/edition-prereqs-tabs.mdx!)

- A web application that you want to protect with Teleport. The web application
  should be running in a private network. In this guide, we assume that the web
  application is available on `app.example.com:3000`.
- A Linux server where you will run the Teleport Application Service. Your
  network must enable the server to connect to your web application.

## Step 1/4. Deploy the Teleport Application Service

In this step, you will configure the Teleport Application Service to proxy a
target application, then deploy a Teleport Agent to run the service.

### Install the Teleport Application Service

Follow the instructions below on the host where you will install the Teleport
Application Service:

(!docs/pages/includes/install-linux.mdx!)

### Configure the Teleport Application Service

On the host where you will run the Teleport Application Service, create a file
at `/etc/teleport.yaml` with the following content:

```yaml
version: v3
teleport:
  join_params:
    token_name: "/tmp/token"
    method: token
  proxy_server: "teleport.example.com:443"
auth_service:
  enabled: off
proxy_service:
  enabled: off
ssh_service:
  enabled: off
app_service:
  enabled: true
  apps:
  # For identifying the app from Teleport client tools
  - name: my-app
    # Domain name and port of teh application
    uri: "app.example.com:3000"
    # Optional application public address to override.
    public_addr: "my-app.teleport.example.com"
    # Optional static labels to assign to the app. Used in RBAC.
    labels:
      env: "prod"
    # Optional dynamic labels to assign to the app. Used in RBAC.
    commands:
    - name: "os"
      command: ["/usr/bin/uname"]
      period: "5s"
```

Edit `/etc/teleport.yaml` to replace `teleport.example.com:443` with the host
and port of your Teleport Proxy Service or Teleport Enterprise (Cloud) account,
e.g., `mytenant.teleport.sh:443`.

The `app_service` field configures the Teleport Application Service. Each item
within `app_service.apps` is an application configuration.

In the example above, we have specified the `uri` field as the address of our
application, `app.example.com:3000`. 

### Run the Teleport Application Service

On the host where you will run the Teleport Application Service, execute the
following command, depending on whether you installed Teleport using a package
manager or via a TAR archive:

(!docs/pages/includes/start-teleport.mdx service="the Teleport Application Service"!)

### Generate a token

A join token is required to authorize a Teleport Application Service to
join the cluster. Generate a short-lived join token and save it for example
in `/tmp/token`:

```code
# Log in to your cluster with tsh so you can use tctl from your local machine.
# You can also run tctl on your Auth Service host without running "tsh login"
# first.
$ tsh login --user=<Var name="myuser"/> --proxy=<Var name="teleport.example.com"/>
$ tctl tokens add \
    --type=app \
    --app-name=grafana \
    --app-uri=http://localhost:3000
```

### TLS requirements

TLS is required to secure the Teleport Access Platform and any connected
applications. When setting up Teleport, the minimum requirement is a certificate
for the Teleport Proxy Service and a wildcard certificate for its sub-domain. This is where
everyone will log into Teleport.

<Admonition type="tip" title="Application Access and DNS">
(!docs/pages/includes/dns-app-access.mdx!)
</Admonition>

In this example:

- `teleport.example.com` hosts the Teleport Auth Service and the Teleport Proxy Service that are the
  that form the core cluster services of the Teleport Access Platform.
- `*.teleport.example.com` hosts all of the applications, for example, `grafana.teleport.example.com`.

(!docs/pages/includes/tls-certificate-setup.mdx!)

### Create a user

A Teleport user needs their role's permission to access an application. Teleport
comes with a built-in `access` role that grants access to all apps:

```code
$ tctl --config=/path/to/teleport.yaml users add --roles=access appuser
```

### Application name

{/*
Note: this section of the docs is linked to from error messages in the product.
Please make sure to update lib/srv/servicecfg/app.go if you change this section
header or move this page.
*/}

An application name should make a valid sub-domain (\<=63 characters, no spaces, only `a-z 0-9 -` allowed).

After Teleport is running, users can access the app at `app-name.proxy_public_addr.com`
e.g. `grafana.teleport.example.com`. You can also override `public_addr` e.g
`grafana.acme.com` if you configure the appropriate DNS entry to point to the
Teleport proxy server.

## Start the Teleport Application Service with a config file

Example `teleport.yaml` configuration:

```yaml
version: v3
teleport:
  # Data directory for the Application Proxy service. If running on the same
  # node as Auth/Proxy service, make sure to use different data directories.
  data_dir: /var/lib/teleport-app
  # Instructs the service to load the auth token from the specified file
  # during initial registration with the cluster.
  auth_token: /tmp/token
  # Proxy address to connect to. Note that it has to be the proxy address
  # because the app service always connects to the cluster over a reverse
  # tunnel.
  proxy_server: teleport.example.com:3080
app_service:
    enabled: yes
    # Teleport provides a small debug app called "dumper" that can be used
    # to make sure application access is working correctly. It outputs JWTs,
    #  so it can be useful when extending your application.
    debug_app: true
    # This section contains definitions of all applications proxied by this
    # service. It can contain multiple items.
    apps:
      # Name of the application. Used for identification purposes.
    - name: "grafana"
      # URI and port the application is available at.
      uri: "http://localhost:3000"
      # Optional application public address to override.
      public_addr: "grafana.teleport.example.com"
      # Optional static labels to assign to the app. Used in RBAC.
      labels:
        env: "prod"
      # Optional dynamic labels to assign to the app. Used in RBAC.
      commands:
      - name: "os"
        command: ["/usr/bin/uname"]
        period: "5s"
auth_service:
  enabled: "no"
ssh_service:
  enabled: "no"
proxy_service:
  enabled: "no"
```

Start the Application Service:

```code
$ sudo teleport start --config=/path/to/teleport.yaml
```

## Advanced options

### Running the dumper application

For testing and debugging purposes, we provide a built-in debug app called "dumper".
It can be turned on using `debug_app: true`.

```yaml
app_service:
   enabled: yes
   debug_app: true
```

The dumper app will dump all the request headers in the response.

### Customize public address

<Admonition
  type="note"
  title="For self-hosted environments only"
>
  The public address of apps cannot be changed or overridden on cloud-hosted Teleport tenants, due to TLS
  certificate limitations.

  For cloud-hosted customers, apps will always be available at `https://<app-name>.example.teleport.sh`, where `example`
  is the name chosen for your cloud-hosted Teleport tenant.
</Admonition>

By default applications are available at `<app-name>.<proxy-host>:<proxy-port>`
address. To override the public address, specify the `public_addr` field:

```yaml
- name: "jira"
  uri: "https://localhost:8001"
  public_addr: "jira.example.com"
```

### Skip TLS certificate verification

<Admonition
  type="warning"
  title="Danger Zone"
>
  This is insecure and not recommended for use in production.
</Admonition>

Teleport checks if the certificates presented by the applications are signed
by a trusted Certificate Authority. When using self-signed certificates for
internal applications, use `insecure_skip_verify: true` to skip this
verification step:

```yaml
- name: "app"
  uri: "https://localhost:8443"
  public_addr: "app.example.com"
  insecure_skip_verify: true
```

### Deeplink to a subdirectory

Some applications are available in a subdirectory. Examples include the
[Kubernetes Dashboard.](https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/).
The URI should be updated to include the subdirectory:

```yaml
- name: "k8s"
  uri: "http://10.0.1.60:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/#/overview"
  public_addr: "k8s.example.com"
```

### Rewrite redirect

To support web apps that perform internal redirects, application access
provides an option to rewrite the hostname of the `Location` header on
redirect responses to the application's public address:

```yaml
- name: "jenkins"
  uri: "https://localhost:8001"
  public_addr: "jenkins.example.com"
  rewrite:
    # Rewrite the "Location" header on redirect responses replacing the
    # host with the public address of this application.
    redirect:
    - "localhost"
    - "jenkins.internal.dev"
```

### Headers passthrough

You can configure application access to inject additional headers in the
requests forwarded to a web application.

<Tabs>
<TabItem label="teleport.yaml syntax">

For apps defined in the `teleport.yaml` configuration, the `headers` field of
each app is a list of strings. Be careful to quote the entire value to ensure it
is parsed correctly.

```yaml
- name: "dashboard"
  uri: https://localhost:4321
  public_addr: dashboard.example.com
  rewrite:
    headers:
    # Inject a static header.
    - "X-Custom-Header: example"
    # Inject headers with internal/external user traits.
    - "X-Internal-Trait: {{internal.logins}}"
    - "X-External-Trait: {{external.env}}"
    # Inject header with Teleport-signed JWT token.
    - "Authorization: Bearer {{internal.jwt}}"
    # Override Host header.
    - "Host: dashboard.example.com"
```

</TabItem>
<TabItem label="Dynamic registration syntax">

In a dynamic `app` resource, configure header rewrites with the
`spec.rewrite.headers` field. The value is a list of mappings that specify the
name and value of each header you would like to rewrite.

```yaml
kind: app
version: v3
metadata:
  name: "dashboard"
spec:
  uri: https://localhost:4321
  public_addr: dashboard.example.com
  rewrite:
    headers:
      # Inject a static header.
      - name: X-Custom-Header
        value: example
      # Inject headers with internal/external user traits.
      - name: X-Internal-Trait
        value: "{{internal.logins}}"
      - name: X-External-Trait
        value: "{{external.env}}"
      # Inject header with Teleport-signed JWT token.
      - name: Authorization
        value: "Bearer {{internal.jwt}}"
      # Override Host header.
      - name: Host
        value: dashboard.example.com
```

</TabItem>
</Tabs>

Headers injected this way override any headers with the same names that may
be sent by an application. The following headers are reserved and can't be
rewritten:

- `Teleport-Jwt-Assertion`
- `Cf-Access-Token`
- Any header matching the pattern `X-Teleport-*`
- Any header matching the pattern `X-Forwarded-*`

Rewritten header values support the same templating variables as
[role templates](../../../access-controls/guides/role-templates.mdx). In the
example above, `X-Internal-Trait` header will be populated with the value of
internal user trait `logins` and `X-External-Trait` header will get the value of
the user's external `env` trait coming from the identity provider.

Additionally, the `{{internal.jwt}}` template variable will be replaced with
a JWT token signed by Teleport that contains user identity information. See
[Integrating with JWTs](../jwt/introduction.mdx) for more details.

For full details on configuring Teleport roles, including how Teleport
populates the `external` and `internal` traits, see the [Teleport Access
Controls Reference](../../../access-controls/reference.mdx).

### Configuring the JWT token

By default, Teleport includes a user's roles and traits in the JWT
generated for application access. If your application doesn't care
about these values, or you are encountering an error due to exceeding
the size limit of HTTP headers, you can configure Teleport to omit
this information from the token.

```yaml
- name: "dashboard"
  uri: https://localhost:4321
  public_addr: dashboard.example.com
  rewrite:
    # Specify whether to include roles or traits in the JWT.
    # Options:
    # - roles-and-traits: include both roles and traits
    # - roles: include only roles
    # - traits: include only traits
    # - none: exclude both roles and traits from the JWT token
    # Default: roles-and-traits
    jwt_claims: roles-and-traits
    headers:
    # Inject header with Teleport-signed JWT token.
    - "Authorization: Bearer {{internal.jwt}}"
```

## View applications in Teleport

Teleport provides a UI for quickly launching connected applications.

They can be viewed by navigating to a cluster's web UI and selecting the "Applications" tab.
The URL structure looks like this:

`https://[cluster-url:cluster-port]/web/cluster/[cluster-name]/apps`

## Logging out of applications

When you log into an application, you'll get a certificate and login session
per your defined RBAC. If you want to force log out before this period you can
do so by hitting the `/teleport-logout` endpoint:

- `https://internal-app.teleport.example.com/teleport-logout`

## Next steps

- Learn how to [configure web apps as TCP apps to access them through
  VNet](vnet.mdx#accessing-web-apps-through-vnet).
